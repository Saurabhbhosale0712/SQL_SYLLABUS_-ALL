

Great! Let’s focus only on the **Expert & Performance Topics in SQL**, with **demo tables**, **realistic use cases**, **queries**, and **expected outputs**.

---

## 📊 **Demo Tables**

### `employees`

| emp\_id | name    | department | salary | hire\_date |
| ------- | ------- | ---------- | ------ | ---------- |
| 1       | Alice   | HR         | 50000  | 2015-06-01 |
| 2       | Bob     | IT         | 80000  | 2016-07-15 |
| 3       | Charlie | IT         | 75000  | 2017-09-10 |
| 4       | David   | Sales      | 60000  | 2019-03-12 |
| 5       | Emma    | HR         | 52000  | 2020-01-20 |

---

### `departments`

| dept\_id | department | location  |
| -------- | ---------- | --------- |
| 1        | HR         | Mumbai    |
| 2        | IT         | Bangalore |
| 3        | Sales      | Hyderabad |

---

## 🔍 **EXPERT & PERFORMANCE SQL TOPICS**

---

### 1. **Indexes**

#### 📌 Use:

Improve **query performance** by reducing lookup time on large tables.

#### 🧩 Query to Create Index:

```sql
CREATE INDEX idx_department ON employees(department);
```

#### 🔍 Use Case:

```sql
SELECT * FROM employees WHERE department = 'IT';
```

#### ✅ Output:

| emp\_id | name    | department | salary | hire\_date |
| ------- | ------- | ---------- | ------ | ---------- |
| 2       | Bob     | IT         | 80000  | 2016-07-15 |
| 3       | Charlie | IT         | 75000  | 2017-09-10 |

📌 **Without Index**: Full table scan
📌 **With Index**: Fast access to matching rows

---

### 2. **Stored Procedures**

#### 📌 Use:

Encapsulate SQL logic in a reusable, callable procedure.

#### 🧩 Create Procedure:

```sql
DELIMITER //

CREATE PROCEDURE GetEmployeesByDept(IN dept_name VARCHAR(50))
BEGIN
   SELECT * FROM employees WHERE department = dept_name;
END //

DELIMITER ;
```

#### 🔍 Call Procedure:

```sql
CALL GetEmployeesByDept('HR');
```

#### ✅ Output:

| emp\_id | name  | department | salary | hire\_date |
| ------- | ----- | ---------- | ------ | ---------- |
| 1       | Alice | HR         | 50000  | 2015-06-01 |
| 5       | Emma  | HR         | 52000  | 2020-01-20 |

---

### 3. **Triggers**

#### 📌 Use:

Automatically perform actions **before/after INSERT/UPDATE/DELETE**.

#### 🧩 Example Trigger:

```sql
CREATE TRIGGER before_employee_insert
BEFORE INSERT ON employees
FOR EACH ROW
SET NEW.hire_date = CURDATE();
```

📌 **Use Case**: Automatically set today's date on new employee hire.

#### 🔍 Insert Query:

```sql
INSERT INTO employees(emp_id, name, department, salary)
VALUES (6, 'Frank', 'Sales', 62000);
```

#### ✅ Output:

New row has current date as `hire_date`.

---

### 4. **Views**

#### 📌 Use:

Create **virtual tables** to simplify complex queries.

#### 🧩 Create View:

```sql
CREATE VIEW it_employees AS
SELECT name, salary FROM employees WHERE department = 'IT';
```

#### 🔍 Use View:

```sql
SELECT * FROM it_employees;
```

#### ✅ Output:

| name    | salary |
| ------- | ------ |
| Bob     | 80000  |
| Charlie | 75000  |

---

### 5. **Transactions & ACID**

#### 📌 Use:

Ensure **data integrity** using transactions.

#### 🧩 Example:

```sql
START TRANSACTION;

UPDATE employees SET salary = salary + 5000 WHERE emp_id = 2;
DELETE FROM employees WHERE emp_id = 99; -- Invalid operation

ROLLBACK; -- Undo everything if error occurs
```

📌 **ACID**:

* **Atomicity**: All or nothing
* **Consistency**: DB remains valid
* **Isolation**: Transactions don’t interfere
* **Durability**: Once committed, data is saved

---

### 6. **Execution Plan (Query Optimization)**

#### 📌 Use:

Understand how SQL queries run & improve performance.

#### 🧩 Use `EXPLAIN`:

```sql
EXPLAIN SELECT * FROM employees WHERE department = 'IT';
```

#### ✅ Output (simplified):

| id | select\_type | table     | type | key             | rows |
| -- | ------------ | --------- | ---- | --------------- | ---- |
| 1  | SIMPLE       | employees | ref  | idx\_department | 2    |

📌 **Check type = ref/index** → Good
📌 **If type = ALL** → Full table scan (optimize it)

---

### 7. **Materialized Views** *(if supported)*

#### 📌 Use:

Store actual results of a query for faster access.

#### 🧩 Syntax (in PostgreSQL/Oracle):

```sql
CREATE MATERIALIZED VIEW employee_summary AS
SELECT department, COUNT(*) AS emp_count
FROM employees
GROUP BY department;
```

📌 Faster than querying original table repeatedly.

---

### 8. **Dynamic SQL**

#### 📌 Use:

Build SQL queries dynamically using variables (common in stored procs).

#### 🧩 Example (MySQL):

```sql
SET @sql = CONCAT('SELECT * FROM employees WHERE department = "', 'HR', '"');
PREPARE stmt FROM @sql;
EXECUTE stmt;
```

#### ✅ Output:

Same as filtering department = 'HR'

---

Would you like this in a **downloadable PDF or Word format** with diagrams and cheat sheets?
